mport numpy as np
#import matplotlib.pyplot as plt
import re

# ====================================================================
# --- GLOBAL PARAMETERS AND HELPERS ---
# ====================================================================

MAX_ITERATIONS = 100
TOLERANCE = 1e-6
VT = 0.02585  # Thermal voltage at room temperature (V)
V_d_crit_fwd = 0.85  # Clipping voltage for Diode/BJT stability


# Function to parse SPICE-like time-dependent sources (e.g., SIN, PULSE)
def parse_source_function(definition, V_DC=0.0):
    """Creates a callable function from a string definition."""
    if isinstance(definition, (int, float)):
        return lambda t: float(definition)

    definition = str(definition)
    match_sin = re.match(r'SIN\(([^ ]+) ([^ ]+) ([^ ]+)\)', definition)
    if match_sin:
        V_offset = float(match_sin.group(1))
        V_peak = float(match_sin.group(2))
        freq = float(match_sin.group(3))
        # V(t) = V_offset + V_peak * sin(2 * pi * f * t)
        return lambda t: V_offset + V_peak * np.sin(2 * np.pi * freq * t)

    try:
        dc_val = float(definition)
        return lambda t: dc_val
    except ValueError:
        return lambda t: V_DC


# ====================================================================
# --- MNA ELEMENT CLASSES ---
# (Includes calculate_current for branch reporting)
# ====================================================================

class Node:
    """Represents a circuit node."""

    def __init__(self, index, name, voltage=0.0):
        self.index = index
        self.name = name
        self.voltage = voltage


class Element:
    """Base class for all circuit elements."""

    def __init__(self, n1: Node, n2: Node):
        self.n1 = n1
        self.n2 = n2

    def stamp(self, j, f, x_guess, delta_t, current_time):
        """Stamps element contribution onto Jacobian (J) and Residual (f)."""
        pass

    def calculate_current(self, x_final, delta_t, current_time):
        """Calculates the current leaving n1 and entering n2 (Branch Current)."""
        return 0.0


class Resistor(Element):
    def __init__(self, value, n1, n2):
        super().__init__(n1, n2)
        self.value = value

    def stamp(self, j, f, x_guess, delta_t, current_time):
        G = 1.0 / self.value
        a, b = self.n1.index, self.n2.index
        v_a, v_b = x_guess[a], x_guess[b]

        j[a, a] += G
        j[b, b] += G
        j[a, b] -= G
        j[b, a] -= G

        f[a] += G * (v_a - v_b)
        f[b] -= G * (v_a - v_b)

    def calculate_current(self, x_final, delta_t, current_time):
        v_a, v_b = x_final[self.n1.index], x_final[self.n2.index]
        return (v_a - v_b) / self.value


class Capacitor(Element):
    def __init__(self, value, n1, n2):
        super().__init__(n1, n2)
        self.value = value
        self.prev_current = 0.0
        self.prev_voltage_diff = 0.0

    def stamp(self, j, f, x_guess, delta_t, current_time):
        C = self.value
        a, b = self.n1.index, self.n2.index
        v_a, v_b = x_guess[a], x_guess[b]
        v_c_guess = v_a - v_b

        G_eq = 2.0 * C / delta_t
        I_eq = G_eq * self.prev_voltage_diff + self.prev_current

        j[a, a] += G_eq
        j[b, b] += G_eq
        j[a, b] -= G_eq
        j[b, a] -= G_eq

        current_guess = G_eq * v_c_guess - I_eq
        f[a] += current_guess
        f[b] -= current_guess

    def calculate_current(self, x_final, delta_t, current_time):
        C = self.value
        v_a, v_b = x_final[self.n1.index], x_final[self.n2.index]
        v_c_final = v_a - v_b

        G_eq = 2.0 * C / delta_t
        I_eq = G_eq * self.prev_voltage_diff + self.prev_current

        return G_eq * v_c_final - I_eq


class Inductor(Element):
    def __init__(self, value, n1, n2):
        super().__init__(n1, n2)
        self.value = value
        self.prev_current = 0.0
        self.prev_voltage_diff = 0.0

    def stamp(self, j, f, x_guess, delta_t, current_time):
        L = self.value
        a, b = self.n1.index, self.n2.index
        v_a, v_b = x_guess[a], x_guess[b]
        v_l_guess = v_a - v_b

        G_eq = delta_t / (2.0 * L)
        I_eq = self.prev_current + G_eq * self.prev_voltage_diff

        j[a, a] += G_eq
        j[b, b] += G_eq
        j[a, b] -= G_eq
        j[b, a] -= G_eq

        current_guess = G_eq * v_l_guess + I_eq
        f[a] += current_guess
        f[b] -= current_guess

    def calculate_current(self, x_final, delta_t, current_time):
        L = self.value
        v_a, v_b = x_final[self.n1.index], x_final[self.n2.index]
        v_l_final = v_a - v_b

        G_eq = delta_t / (2.0 * L)
        I_eq = self.prev_current + G_eq * self.prev_voltage_diff

        return G_eq * v_l_final + I_eq


class VoltageSource(Element):
    def __init__(self, value_func, n1, n2, aux_index):
        super().__init__(n1, n2)
        self.value_func = value_func
        self.aux_index = aux_index

    def stamp(self, j, f, x_guess, delta_t, current_time):
        a, b = self.n1.index, self.n2.index
        m = self.aux_index

        v_a, v_b = x_guess[a], x_guess[b]
        V_s = self.value_func(current_time)

        j[a, m] += 1
        j[b, m] -= 1
        j[m, a] += 1
        j[m, b] -= 1
        f[m] += v_a - v_b - V_s

    def calculate_current(self, x_final, delta_t, current_time):
        return x_final[self.aux_index]


class CurrentSource(Element):
    def __init__(self, value_func, n1, n2):
        super().__init__(n1, n2)
        self.value_func = value_func

    def stamp(self, j, f, x_guess, delta_t, current_time):
        a, b = self.n1.index, self.n2.index
        I_s = self.value_func(current_time)
        f[a] += I_s
        f[b] -= I_s

    def calculate_current(self, x_final, delta_t, current_time):
        return self.value_func(current_time)


class Diode(Element):
    def __init__(self, n1, n2, Is=1e-15, n=1.0):
        super().__init__(n1, n2)
        self.Is = Is
        self.n = n

    def stamp(self, j, f, x_guess, delta_t, current_time):
        a, b = self.n1.index, self.n2.index
        v_d = x_guess[a] - x_guess[b]

        if v_d > V_d_crit_fwd:
            g_crit = self.Is / (self.n * VT) * np.exp(V_d_crit_fwd / (self.n * VT))
            i_crit = self.Is * (np.exp(V_d_crit_fwd / (self.n * VT)) - 1)
            g_d = g_crit
            i_d = i_crit + g_crit * (v_d - V_d_crit_fwd)
        else:
            arg = v_d / (self.n * VT)
            exp_val = np.exp(arg)
            i_d = self.Is * (exp_val - 1)
            g_d = (self.Is / (self.n * VT)) * exp_val

        j[a, a] += g_d
        j[b, b] += g_d
        j[a, b] -= g_d
        j[b, a] -= g_d
        f[a] += i_d
        f[b] -= i_d

    def calculate_current(self, x_final, delta_t, current_time):
        v_d = x_final[self.n1.index] - x_final[self.n2.index]

        if v_d > V_d_crit_fwd:
            g_crit = self.Is / (self.n * VT) * np.exp(V_d_crit_fwd / (self.n * VT))
            i_crit = self.Is * (np.exp(V_d_crit_fwd / (self.n * VT)) - 1)
            return i_crit + g_crit * (v_d - V_d_crit_fwd)
        else:
            arg = v_d / (self.n * VT)
            return self.Is * (np.exp(arg) - 1)


class BJT_NPN:  # 3-terminal devices do not inherit from Element base class
    def __init__(self, nc, nb, ne, Is=1e-14, bf=100.0, br=1.0):
        self.nc, self.nb, self.ne = nc, nb, ne
        self.Is, self.bf, self.br = Is, bf, br
        self.alpha_f = bf / (1.0 + bf)
        self.alpha_r = br / (1.0 + br)

    def _calculate_currents(self, v_c, v_b, v_e):
        """Helper to calculate terminal currents based on terminal voltages."""
        v_be = v_b - v_e
        v_bc = v_b - v_c

        v_be = np.clip(v_be, a_min=None, a_max=V_d_crit_fwd)
        v_bc = np.clip(v_bc, a_min=None, a_max=V_d_crit_fwd)

        exp_be = np.exp(v_be / VT)
        exp_bc = np.exp(v_bc / VT)

        I_BE = self.Is * (exp_be - 1.0)
        I_BC = self.Is * (exp_bc - 1.0)
        g_be = self.Is / VT * exp_be
        g_bc = self.Is / VT * exp_bc

        I_C = self.alpha_f * I_BE - I_BC * (1.0 + 1.0 / self.br)
        I_E = -I_BE * (1.0 + 1.0 / self.bf) + self.alpha_r * I_BC
        I_B = -(I_C + I_E)

        return I_C, I_B, I_E, g_be, g_bc

    def stamp(self, j, f, x_guess, delta_t, current_time):
        c, b, e = self.nc.index, self.nb.index, self.ne.index
        v_c, v_b, v_e = x_guess[c], x_guess[b], x_guess[e]

        I_C, I_B, I_E, g_be, g_bc = self._calculate_currents(v_c, v_b, v_e)

        j[c, b] += self.alpha_f * g_be - g_bc * (1.0 + 1.0 / self.br)
        j[c, e] -= self.alpha_f * g_be
        j[c, c] += g_bc * (1.0 + 1.0 / self.br)

        j[e, b] -= g_be * (1.0 + 1.0 / self.bf) + self.alpha_r * g_bc
        j[e, e] += g_be * (1.0 + 1.0 / self.bf)
        j[e, c] -= self.alpha_r * g_bc

        j[b, c] = -(j[c, c] + j[e, c])
        j[b, b] = -(j[c, b] + j[e, b])
        j[b, e] = -(j[c, e] + j[e, e])

        f[c] += I_C
        f[b] += I_B
        f[e] += I_E

    def calculate_current(self, x_final, delta_t, current_time):
        """Returns I_C (Collector Current) as the primary branch current."""
        v_c, v_b, v_e = x_final[self.nc.index], x_final[self.nb.index], x_final[self.ne.index]
        I_C, I_B, I_E, _, _ = self._calculate_currents(v_c, v_b, v_e)
        return I_C

